import sys
from collections import deque

sequences = []в
for line in sys.stdin:  # Считываем все последовательности из потока стандартного ввода, по одной в строке
    if len(line.split()) == 2:
        start_seq, finish_seq = [int(x) for x in line.split()]  # считываем номера последовательностей,
        # между которыми нужно
        # найти путь, в одной строке через пробел
        break
    sequences.append(line)  # Добавляем их по одной в список
start_seq -= 1  # переведем номера последовательностей в 0-индексацию для удобства
finish_seq -= 1


def is_direct_path(seq_1, seq_2):  # Функция, проверяющая, есть ли прямой переход между последовательностями
    return seq_1[:6] == seq_2[:6] or seq_1[-6:] == seq_2[-6:]


# Для решения задачи будем использовать алгоритм для нахождения кратчайших путей в графе - поиск в ширину (BFS)
# Будем считать, что сами последовательности - вершины графа, а возможности прямого перехода - ребра между ними
def bfs(start, finish):
    n = len(sequences)  # запишем количество последовательностей в переменную n
    distances = [2e9] * n  # заведем массив, в котором будем хранить расстояния от стартовой вершины до всех остальных
    prev = [-1] * n  # а также еще один массив, чтобы сохранять предков
    # (предок для последовательности - последовательность, из которой пришли в текущую, когда искали кратчайший путь)
    distances[start] = 0  # расстояние от стартовой до стартовой логично равно нулю
    q = deque([start])  # В соотвествие с алгоритмом положим стартовую вершину в очередь
    while q:  # Пока очередь не пуста, проделываем очередной шаг алгоритма
        v = q.popleft()  # Вытаскиваем из очереди последовательность, которая была туда раньше положена
        for u in range(n):  # Проходимся по всем последовательностям
            if is_direct_path(sequences[v], sequences[u]):  # и смотрим, можно ли из одной напрямую получить другую
                if distances[u] == 2e9:  # Если можно, смотрим, побывали ли мы уже в этой последовательности
                    distances[u] = distances[v] + 1  # И если нет, то обновляем расстояние,
                    prev[u] = v  # обновляем предка
                    q.append(u)  # И пихаем новую вершину в очередь
    dist = distances[finish]  # в массиве distances интересующая нас величина лежит по индексу finish
    if dist == 2e9:  # если дистанция равна исходному значению, значит, пути нет
        return None, []  # возвращаем None, пустой список в знак того, что кратчайший путь не был найден

    # Теперь восстанавливаем путь от стартовой до конечной вершины, он будет лежать в массиве p
    p = [finish]  # сначала там только финальная вершина
    while prev[p[-1]] != -1:  # пока предок в пути у вершины есть
        p.append(prev[p[-1]])  # пихаем его в путь
    p.reverse()  # путь получился перевернутым (от finish до start), чтобы сделать его нормальным, перевернем
    return dist, p  # первым параметром вернем длину пути, а вторым - собственно путь


distance, path = bfs(start_seq, finish_seq)  # Посчитаем длину и путь
if distance is None:
    # Если пути нет, говорим об этом
    print('Невозможно получить из одной последовательности другую')
else:
    # А если есть, выведем
    print(f'Длина пути между последовательностями - {distance}. Сам путь: ')
    print('\t\t   ||   \t\t\n'.join([sequences[i] for i in path]))
